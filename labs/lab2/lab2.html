<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Cameron Hernandez">
<meta name="dcterms.date" content="2025-09-11">
<meta name="description" content="In this lab you will learn how to use time multiplexing to efficiently use the I/O on your FPGA.">

<title>Lab 2: Multiplexed 7-Segment Display – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blogs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#hours-spent" id="toc-hours-spent" class="nav-link active" data-scroll-target="#hours-spent">Hours Spent:</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction:</a></li>
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram:</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic:</a>
  <ul class="collapse">
  <li><a href="#calculations" id="toc-calculations" class="nav-link" data-scroll-target="#calculations">Calculations:</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results:</a></li>
  <li><a href="#ai-prototype" id="toc-ai-prototype" class="nav-link" data-scroll-target="#ai-prototype">AI Prototype:</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 2: Multiplexed 7-Segment Display</h1>
  <div class="quarto-categories">
    <div class="quarto-category">reflection</div>
    <div class="quarto-category">labreport</div>
  </div>
  </div>

<div>
  <div class="description">
    In this lab you will learn how to use time multiplexing to efficiently use the I/O on your FPGA.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Cameron Hernandez </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 11, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="hours-spent" class="level2">
<h2 class="anchored" data-anchor-id="hours-spent">Hours Spent:</h2>
<p>34</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction:</h2>
<p>This lab required the use of time multiplexing to efficiently use I/O pins on the FPGA board. This involved a time-multiplexing scheme driving two seven-segment displays shorted together using a single set of FPGA I/O pins. This required the use of two PNP switches which worked opposite where if one was driven high, the other was low. To cycle between the displays a 60Hz clock divider was used to determine which PNP was active, allowing for the control of the two different display screens.</p>
<p>The display screens function like they did in the previous lab, where inside leds would activate depending on the inputs from a 4 bit DIP Switch. Here two DIP Switches are used to control a corresponding screen. The segment display outputs a hexadecimal value corresponding to the value imputed from the DIP Switch.</p>
<p>Furthermore, five leds display the binary numerical value of the sum of the two DIP Switches. Depending on the configuration of the DIP switches the binary representation value could range between 0+0 to F + F.</p>
<p>Technical Documentation: The source code for this project can be found in the associated Github repository here: <a href="https://github.com/Cameron-Hernandez-HM/E155/tree/main/Lab1_CH">GitHub_Lab2_CH</a></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/completedBoard.JPG" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Finished Board, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
</section>
<section id="block-diagram" class="level2">
<h2 class="anchored" data-anchor-id="block-diagram">Block Diagram:</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/blockDiagram.JPG" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Block Diagram, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
<p>Figure 2 illustrates a block diagram of the architecture of the design for lab 2. The top module takes in the inputs for the two 4-bit DIP Switches. Here they go into a mode which selects which dipswitch will output to the segment display module which controls the outputs of the leds on the segment display. This mux is governed by the bit value ledState which flips every 60Hz as instructed by the clkWorld module which accepts a high speed oscillation clock. Furthermore, ledState is what determines which enable will be activated.</p>
<p>Going back to the DIP switches, their logic is also passed into an adder block which combines the binary values of the switches into a 5 bit value. This is then negated as we are in active low. Lastly, leaving the segmentDisplay module we have our seven bit value seg which is what determines which led lights will be activated on the segment display.</p>
</section>
<section id="schematic" class="level2">
<h2 class="anchored" data-anchor-id="schematic">Schematic:</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/schematic.JPG" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Schematic, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
<p>Figure 3 illustrates a the schematic of the system where two sets of four switches which connect into the FPGA block ICE40UP5K-S648. Each switch connects to a corresponding pin where there is a 100KΩ internal resistor that then connects to the 3.3V supply. Output from the FPGA pins, specifically pins 10, 42, 19, 11 and 38 connect to an 5 leds which each have a 1kΩ pull down resistor. A 3.3V from the FPGA powers the HD5P-521A-523A seven segment display which internally has 14 leds. These leds first connect to a 240Ω resistor to allow for a minimal current to enter the FPGA as well as allowing for a bright display. These pins are then shorted to their corresponding match and then inputed into the FPGA</p>
<section id="calculations" class="level3">
<h3 class="anchored" data-anchor-id="calculations">Calculations:</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/calculations.JPG" class="img-fluid figure-img"></p>
<figcaption>Figure 4: Calculations, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results:</h2>
<p>The design met all the intended design objectives. A testbench was written to ensure that the three leds flash when their requirements are met as well as ensure that the fourteen different leds on the segment display output correctly based on the input logic of the DIP switches.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/TB_Wave.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: Top Module Test Bench Waveforms, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/TB_Console.png" class="img-fluid figure-img"></p>
<figcaption>Figure 6: Top Module Test Bench Terminal Report, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/SegmentDispTBWaves.png" class="img-fluid figure-img"></p>
<figcaption>Figure 7: SegmentDisp Test Bench Waveforms, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/SegmentDispTBLog.png" class="img-fluid figure-img"></p>
<figcaption>Figure 8: SegmentDisp Test Bench Terminal Report, Cameron Hernandez, 9/3/2025</figcaption>
</figure>
</div>
</section>
<section id="ai-prototype" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype">AI Prototype:</h2>
<p>For the AI prototype I asked ChatGPT if it could Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.</p>
<p>It thought for four seconds and then gave me this:</p>
<p>// single file: dual_muxed_7seg.sv // Single combinational 7-seg decoder + time-multiplexing top module // Segment bit order: {a,b,c,d,e,f,g} (MSB a, LSB g)</p>
<p>`timescale 1ns/1ps</p>
<p>module seven_seg_decoder #( parameter logic ACTIVE_LOW = 1’b1 // set 1 for common-anode (active low segments) ) ( input logic [3:0] nibble, output logic [6:0] seg // {a,b,c,d,e,f,g} ); logic [6:0] seg_raw;</p>
<pre><code>always_comb begin
    // Default: blank (all off)
    seg_raw = 7'b111_1111;

    case (nibble)
        4'h0: seg_raw = 7'b111_1110; // a b c d e f on, g off (note: we'll invert for active_low below)
        4'h1: seg_raw = 7'b011_0000; // segments b c
        4'h2: seg_raw = 7'b110_1101; // a b d e g
        4'h3: seg_raw = 7'b111_1001; // a b c d g
        4'h4: seg_raw = 7'b011_0011; // b c f g
        4'h5: seg_raw = 7'b101_1011; // a c d f g
        4'h6: seg_raw = 7'b101_1111; // a c d e f g
        4'h7: seg_raw = 7'b111_0000; // a b c
        4'h8: seg_raw = 7'b111_1111; // all segments
        4'h9: seg_raw = 7'b111_1011; // a b c d f g
        4'hA: seg_raw = 7'b111_0111; // a b c e f g (A)
        4'hB: seg_raw = 7'b001_1111; // c d e f g (lowercase b)
        4'hC: seg_raw = 7'b100_1110; // a d e f (C)
        4'hD: seg_raw = 7'b011_1101; // b c d e g (lowercase d)
        4'hE: seg_raw = 7'b100_1111; // a d e f g (E)
        4'hF: seg_raw = 7'b100_0111; // a e f g (F)
        default: seg_raw = 7'b000_0000; // all off as safety (shouldn't happen)
    endcase

    // NOTE: above bit patterns assume '1' means segment ON.
    // If your hardware expects active-low (1 = off, 0 = on), we invert here.
    if (ACTIVE_LOW)
        seg = ~seg_raw;
    else
        seg = seg_raw;
end</code></pre>
<p>endmodule</p>
<p>// Top module: time-multiplex single decoder to produce two sets of 7 outputs. module dual_muxed_7seg #( parameter integer CNT_WIDTH = 16, // width of refresh counter: adjust for refresh period parameter logic ACTIVE_LOW = 1’b1 // match decoder’s active level (common anode -&gt; 1) ) ( input logic clk, // system clock input logic rst_n, // active-low reset input logic [3:0] nibble0, // first nibble to show input logic [3:0] nibble1, // second nibble to show output logic [6:0] seg_out0, // decoded segments for digit0 {a,b,c,d,e,f,g} output logic [6:0] seg_out1 // decoded segments for digit1 );</p>
<pre><code>// refresh counter to generate a slow select signal
logic [CNT_WIDTH-1:0] counter;
logic select; // 0 =&gt; nibble0, 1 =&gt; nibble1

// single decoder output
logic [6:0] decoder_out;

// instantiate the single decoder
seven_seg_decoder #(.ACTIVE_LOW(ACTIVE_LOW)) decoder_inst (
    .nibble(decoder_selected_nibble()),
    .seg(decoder_out)
);

// function to return selected nibble (combinational)
function automatic logic [3:0] decoder_selected_nibble ();
    decoder_selected_nibble = select ? nibble1 : nibble0;
endfunction

// refresh counter
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        counter &lt;= '0;
    end else begin
        counter &lt;= counter + 1'b1;
    end
end

// choose select bit from the MSB of the counter (gives ~clk/2^(CNT_WIDTH-1) refresh)
always_comb begin
    select = counter[CNT_WIDTH-1];
end

// latch decoder output into the appropriate output register on each clock edge.
// When select==0 the decoder is producing nibble0 -&gt; store to seg_out0.
// When select==1 the decoder is producing nibble1 -&gt; store to seg_out1.
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        seg_out0 &lt;= '0;
        seg_out1 &lt;= '0;
    end else begin
        if (select) begin
            seg_out1 &lt;= decoder_out;
        end else begin
            seg_out0 &lt;= decoder_out;
        end
    end
end</code></pre>
<p>endmodule</p>
<p>I was very surprised at how quickly it responded so I was eager to test and see if this code would work. To my surprise, the code did synthesize but then failed in the routing as I think I need to set up the FPGA ports. If I spent time actually defining the ports and wired things up properly I belive that this code actually would work. I am surprised by its syntax as it uses &lt;= inside always ff blocks which I believe is not entirely necessary. Also, the comments are really well crafted and properly ordered. I think that this code did a really good job. For the next assignment I asked Chat to write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.</p>
<p>It gave me this: //====================================================== // Dual time-multiplexed 7-segment display driver // Uses: provided seven_seg_decoder.sv and oscillator.sv //======================================================</p>
<p>module dual_muxed_7seg ( input logic clk, // system clock input logic rst_n, // active-low reset input logic [3:0] nibble0, // first input digit input logic [3:0] nibble1, // second input digit output logic [6:0] seg_out0, // decoded outputs for digit0 output logic [6:0] seg_out1 // decoded outputs for digit1 );</p>
<pre><code>// signal from oscillator (acts as a refresh toggle)
logic sel;

// output of single decoder
logic [6:0] seg_temp;

// oscillator instance (provided in your files)
oscillator u_osc (
    .clk   (clk),
    .rst_n (rst_n),
    .sel   (sel)    // toggles at refresh rate
);

// single 7-seg decoder instance (provided in your files)
seven_seg_decoder u_dec (
    .nibble (sel ? nibble1 : nibble0),
    .seg    (seg_temp)
);

// capture decoder result into the appropriate output
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        seg_out0 &lt;= '0;
        seg_out1 &lt;= '0;
    end else begin
        if (sel)
            seg_out1 &lt;= seg_temp;  // update digit1
        else
            seg_out0 &lt;= seg_temp;  // update digit0
    end
end</code></pre>
<p>endmodule</p>
<p>This code did not synthesize and gives an error that says an issue with .nibble.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/Cameron-Hernandez-HM\.github\.io\/E155\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>