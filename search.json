[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Page"
  },
  {
    "objectID": "resources.html#links",
    "href": "resources.html#links",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Page"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing\n\n\nIn this lab you will familiarize yourself with the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards we will be using this semester.\n\n\n\n\n\nSep 4, 2025\n\n\nCameron Hernandez\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\nIn this lab you will learn how to use time multiplexing to efficiently use the I/O on your FPGA.\n\n\n\n\n\nSep 11, 2025\n\n\nCameron Hernandez\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3: Keypad Scanner\n\n\nIn this lab you will learn how to use an FPGA to scan inputs from a keypad.\n\n\n\n\n\nSep 18, 2025\n\n\nCameron Hernandez\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4: Digital Audio\n\n\nIn this lab you will use your MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations.\n\n\n\n\n\nOct 2, 2025\n\n\nCameron Hernandez\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5: Interrupts\n\n\nIn this lab you will use your MCU to determine the speed of a motor by reading from a quadrature encoder using interrupts.\n\n\n\n\n\nOct 9, 2025\n\n\nCameron Hernandez\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6: The Internet of Things and Serial Peripheral Interface\n\n\nIn this lab, you will learn how to design and build an Internet of Things (IoT) device by implementing SPI communication on an MCU, interfacing with a temperature sensor and an ESP8266 WiFi module, debugging serial protocols with a logic analyzer, and creating an HTML webpage to control an LED and display real-time temperature data.\n\n\n\n\n\nOct 23, 2025\n\n\nCameron Hernandez\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7: The Advanced Encryption Standard\n\n\nIn this lab, you will design and implement a hardware accelerator on an FPGA to perform 128-bit AES encryption, interface it with an MCU over SPI, debug your system using a logic analyzer, and gain hands-on experience with reading complex specifications, hardware architecture, and hardware-software integration.\n\n\n\n\n\nOct 30, 2025\n\n\nCameron Hernandez\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "34"
  },
  {
    "objectID": "labs/lab2/lab2.html#hours-spent",
    "href": "labs/lab2/lab2.html#hours-spent",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "34"
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Introduction:",
    "text": "Introduction:\nThis lab required the use of time multiplexing to efficiently use I/O pins on the FPGA board. This involved a time-multiplexing scheme driving two seven-segment displays shorted together using a single set of FPGA I/O pins. This required the use of two PNP switches which worked opposite where if one was driven high, the other was low. To cycle between the displays a 60Hz clock divider was used to determine which PNP was active, allowing for the control of the two different display screens.\nThe display screens function like they did in the previous lab, where inside leds would activate depending on the inputs from a 4 bit DIP Switch. Here two DIP Switches are used to control a corresponding screen. The segment display outputs a hexadecimal value corresponding to the value imputed from the DIP Switch.\nFurthermore, five leds display the binary numerical value of the sum of the two DIP Switches. Depending on the configuration of the DIP switches the binary representation value could range between 0+0 to F + F.\nTechnical Documentation: The source code for this project can be found in the associated Github repository here: GitHub_Lab2_CH\n\n\n\nFigure 1: Finished Board, Cameron Hernandez, 9/3/2025"
  },
  {
    "objectID": "labs/lab2/lab2.html#block-diagram",
    "href": "labs/lab2/lab2.html#block-diagram",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Block Diagram:",
    "text": "Block Diagram:\n\n\n\nFigure 2: Block Diagram, Cameron Hernandez, 9/3/2025\n\n\nFigure 2 illustrates a block diagram of the architecture of the design for lab 2. The top module takes in the inputs for the two 4-bit DIP Switches. Here they go into a mode which selects which dipswitch will output to the segment display module which controls the outputs of the leds on the segment display. This mux is governed by the bit value ledState which flips every 60Hz as instructed by the clkWorld module which accepts a high speed oscillation clock. Furthermore, ledState is what determines which enable will be activated.\nGoing back to the DIP switches, their logic is also passed into an adder block which combines the binary values of the switches into a 5 bit value. This is then negated as we are in active low. Lastly, leaving the segmentDisplay module we have our seven bit value seg which is what determines which led lights will be activated on the segment display."
  },
  {
    "objectID": "labs/lab2/lab2.html#schematic",
    "href": "labs/lab2/lab2.html#schematic",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Schematic:",
    "text": "Schematic:\n\n\n\nFigure 3: Schematic, Cameron Hernandez, 9/3/2025\n\n\nFigure 3 illustrates a the schematic of the system where two sets of four switches which connect into the FPGA block ICE40UP5K-S648. Each switch connects to a corresponding pin where there is a 100KŒ© internal resistor that then connects to the 3.3V supply. Output from the FPGA pins, specifically pins 10, 42, 19, 11 and 38 connect to an 5 leds which each have a 1kŒ© pull down resistor. A 3.3V from the FPGA powers the HD5P-521A-523A seven segment display which internally has 14 leds. These leds first connect to a 240Œ© resistor to allow for a minimal current to enter the FPGA as well as allowing for a bright display. These pins are then shorted to their corresponding match and then inputed into the FPGA\n\nCalculations:\n\n\n\nFigure 4: Calculations, Cameron Hernandez, 9/3/2025"
  },
  {
    "objectID": "labs/lab2/lab2.html#results",
    "href": "labs/lab2/lab2.html#results",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results:",
    "text": "Results:\nThe design met all the intended design objectives. A testbench was written to ensure that the three leds flash when their requirements are met as well as ensure that the fourteen different leds on the segment display output correctly based on the input logic of the DIP switches.\n\n\n\nFigure 5: Top Module Test Bench Waveforms, Cameron Hernandez, 9/3/2025\n\n\n\n\n\nFigure 6: Top Module Test Bench Terminal Report, Cameron Hernandez, 9/3/2025\n\n\n\n\n\nFigure 7: SegmentDisp Test Bench Waveforms, Cameron Hernandez, 9/3/2025\n\n\n\n\n\nFigure 8: SegmentDisp Test Bench Terminal Report, Cameron Hernandez, 9/3/2025"
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype:",
    "text": "AI Prototype:\nFor the AI prototype I asked ChatGPT if it could Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\nIt thought for four seconds and then gave me this:\n// single file: dual_muxed_7seg.sv // Single combinational 7-seg decoder + time-multiplexing top module // Segment bit order: {a,b,c,d,e,f,g} (MSB a, LSB g)\n`timescale 1ns/1ps\nmodule seven_seg_decoder #( parameter logic ACTIVE_LOW = 1‚Äôb1 // set 1 for common-anode (active low segments) ) ( input logic [3:0] nibble, output logic [6:0] seg // {a,b,c,d,e,f,g} ); logic [6:0] seg_raw;\nalways_comb begin\n    // Default: blank (all off)\n    seg_raw = 7'b111_1111;\n\n    case (nibble)\n        4'h0: seg_raw = 7'b111_1110; // a b c d e f on, g off (note: we'll invert for active_low below)\n        4'h1: seg_raw = 7'b011_0000; // segments b c\n        4'h2: seg_raw = 7'b110_1101; // a b d e g\n        4'h3: seg_raw = 7'b111_1001; // a b c d g\n        4'h4: seg_raw = 7'b011_0011; // b c f g\n        4'h5: seg_raw = 7'b101_1011; // a c d f g\n        4'h6: seg_raw = 7'b101_1111; // a c d e f g\n        4'h7: seg_raw = 7'b111_0000; // a b c\n        4'h8: seg_raw = 7'b111_1111; // all segments\n        4'h9: seg_raw = 7'b111_1011; // a b c d f g\n        4'hA: seg_raw = 7'b111_0111; // a b c e f g (A)\n        4'hB: seg_raw = 7'b001_1111; // c d e f g (lowercase b)\n        4'hC: seg_raw = 7'b100_1110; // a d e f (C)\n        4'hD: seg_raw = 7'b011_1101; // b c d e g (lowercase d)\n        4'hE: seg_raw = 7'b100_1111; // a d e f g (E)\n        4'hF: seg_raw = 7'b100_0111; // a e f g (F)\n        default: seg_raw = 7'b000_0000; // all off as safety (shouldn't happen)\n    endcase\n\n    // NOTE: above bit patterns assume '1' means segment ON.\n    // If your hardware expects active-low (1 = off, 0 = on), we invert here.\n    if (ACTIVE_LOW)\n        seg = ~seg_raw;\n    else\n        seg = seg_raw;\nend\nendmodule\n// Top module: time-multiplex single decoder to produce two sets of 7 outputs. module dual_muxed_7seg #( parameter integer CNT_WIDTH = 16, // width of refresh counter: adjust for refresh period parameter logic ACTIVE_LOW = 1‚Äôb1 // match decoder‚Äôs active level (common anode -&gt; 1) ) ( input logic clk, // system clock input logic rst_n, // active-low reset input logic [3:0] nibble0, // first nibble to show input logic [3:0] nibble1, // second nibble to show output logic [6:0] seg_out0, // decoded segments for digit0 {a,b,c,d,e,f,g} output logic [6:0] seg_out1 // decoded segments for digit1 );\n// refresh counter to generate a slow select signal\nlogic [CNT_WIDTH-1:0] counter;\nlogic select; // 0 =&gt; nibble0, 1 =&gt; nibble1\n\n// single decoder output\nlogic [6:0] decoder_out;\n\n// instantiate the single decoder\nseven_seg_decoder #(.ACTIVE_LOW(ACTIVE_LOW)) decoder_inst (\n    .nibble(decoder_selected_nibble()),\n    .seg(decoder_out)\n);\n\n// function to return selected nibble (combinational)\nfunction automatic logic [3:0] decoder_selected_nibble ();\n    decoder_selected_nibble = select ? nibble1 : nibble0;\nendfunction\n\n// refresh counter\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter &lt;= '0;\n    end else begin\n        counter &lt;= counter + 1'b1;\n    end\nend\n\n// choose select bit from the MSB of the counter (gives ~clk/2^(CNT_WIDTH-1) refresh)\nalways_comb begin\n    select = counter[CNT_WIDTH-1];\nend\n\n// latch decoder output into the appropriate output register on each clock edge.\n// When select==0 the decoder is producing nibble0 -&gt; store to seg_out0.\n// When select==1 the decoder is producing nibble1 -&gt; store to seg_out1.\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        seg_out0 &lt;= '0;\n        seg_out1 &lt;= '0;\n    end else begin\n        if (select) begin\n            seg_out1 &lt;= decoder_out;\n        end else begin\n            seg_out0 &lt;= decoder_out;\n        end\n    end\nend\nendmodule\nI was very surprised at how quickly it responded so I was eager to test and see if this code would work. To my surprise, the code did synthesize but then failed in the routing as I think I need to set up the FPGA ports. If I spent time actually defining the ports and wired things up properly I belive that this code actually would work. I am surprised by its syntax as it uses &lt;= inside always ff blocks which I believe is not entirely necessary. Also, the comments are really well crafted and properly ordered. I think that this code did a really good job. For the next assignment I asked Chat to write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\nIt gave me this: //====================================================== // Dual time-multiplexed 7-segment display driver // Uses: provided seven_seg_decoder.sv and oscillator.sv //======================================================\nmodule dual_muxed_7seg ( input logic clk, // system clock input logic rst_n, // active-low reset input logic [3:0] nibble0, // first input digit input logic [3:0] nibble1, // second input digit output logic [6:0] seg_out0, // decoded outputs for digit0 output logic [6:0] seg_out1 // decoded outputs for digit1 );\n// signal from oscillator (acts as a refresh toggle)\nlogic sel;\n\n// output of single decoder\nlogic [6:0] seg_temp;\n\n// oscillator instance (provided in your files)\noscillator u_osc (\n    .clk   (clk),\n    .rst_n (rst_n),\n    .sel   (sel)    // toggles at refresh rate\n);\n\n// single 7-seg decoder instance (provided in your files)\nseven_seg_decoder u_dec (\n    .nibble (sel ? nibble1 : nibble0),\n    .seg    (seg_temp)\n);\n\n// capture decoder result into the appropriate output\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        seg_out0 &lt;= '0;\n        seg_out1 &lt;= '0;\n    end else begin\n        if (sel)\n            seg_out1 &lt;= seg_temp;  // update digit1\n        else\n            seg_out0 &lt;= seg_temp;  // update digit0\n    end\nend\nendmodule\nThis code did not synthesize and gives an error that says an issue with .nibble."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "My name is Cameron Hernandez, I am a Senior at Harvey Mudd College currently perusing a bachelors in engineering. I am is passionate about electronic hardware and circuit designs. I have expierence ranging from working with power electronincs, desigining autonomous robotics, simulating electrically small antennas, and creating a multicycle processor. Stepping away from electrical engineering, I have taken engineering courses in the chemical, mechanical, material, and systems domains."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blogs",
    "section": "",
    "text": "The Beginning of Something Great\n\n\nInitial reflection for the start of E155\n\n\n\n\n\nAug 29, 2025\n\n\nCameron Hernandez\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "34"
  },
  {
    "objectID": "labs/lab1/lab1.html#hours-spent",
    "href": "labs/lab1/lab1.html#hours-spent",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "34"
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Introduction:",
    "text": "Introduction:\nThis lab required an implemented design on the FPGA to demonstrate functionality of an on-board high-speed oscillator via blinking an LEDs. To achieve this required a 24MHz frequency configuration on the high speed oscillator which was undivided down using a counter to achieve a blinking frequency of 2.4 Hz. Furthermore, 4 DIP switches which represented a binary input were used to configure a 7-segment display where each different binary value corresponded to a hexadecimal representation on the segment display. Design and Testing Methodology: Onboard the FPGA lies the HSOSC which outputs a clock that operates at a frequency of 24MHz. Using a counter set to divide the operating frequency once it reached a value of 5M resulted in an LED blinking every 1/(2.4) seconds, which corresponds to 2.4Hz. This divider is instantiated in the top module. This LED was defined as led[2]\nA seven segment display was placed on a breadboard which utilized a 3.3V source. 1kŒ© current limiting resistors connecting to ground at the FPGA pins allowed for a safe amount of current to flow through the system. To control each led in the seven segment display combinational logic from a four input DIP switch was utilized where combinational logic from the switches would translate a binary value to its corresponding hexadecimal value which would appear on the seven segment display. This display ranged from 0 to F as the four different switches corresponded to 16 total configurations.\nIn total three LEDs were utilized where led[2] corresponded to the blinking 2.4Hz signal, led[1] utilized the combinational DIP switches which would only activate if both s[3] & s[2] were high. led[0] was configured as an xor relying on the inputs of the first two DIP switches s[1] ^ s[0]. Technical Documentation: The source code for this project can be found in the associated Github repository here: GitHub_Lab1_CH\n\n\n\nFigure 1: Finished Board, Cameron Hernandez, 9/3/2025\n\n\n\n\n\nFigure 2: Associated Breadboard, Cameron Hernandez, 9/3/2025"
  },
  {
    "objectID": "labs/lab1/lab1.html#block-diagram",
    "href": "labs/lab1/lab1.html#block-diagram",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Block Diagram:",
    "text": "Block Diagram:\n\n\n\nFigure 1: Block Diagram, Cameron Hernandez, 9/3/2025\n\n\nFigure 1 illustrates a block diagram of the architecture of the design for lab 1. The top module takes a 4 bus input, which corresponds to the 4 DIP switch. The dipswitches input into a submodule called segmentDisp which controls the seven segment display. Outputting from segmentDisp are the 7 corresponding led‚Äôs on the seven segment display which are what control when each individual led on the display lighting up. These are connected to Pins 3, 45, 20, 12, 18, 44, and 9. The DIP switches also pass into an ‚Äúand‚Äù gate and an ‚Äúxor‚Äù gate which control two leds off the board. Lastly, the built in HSOSC controls a timer which then outputs a 2.4Hz signal which controls a third led."
  },
  {
    "objectID": "labs/lab1/lab1.html#schematic",
    "href": "labs/lab1/lab1.html#schematic",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Schematic:",
    "text": "Schematic:\n\n\n\nFigure 2: Schematic, Cameron Hernandez, 9/3/2025\n\n\nMy schematic, figure 2, illustrates four switches which connect into the FPGA block ICE40UP5K-S648. Each switch connects to a corresponding pin where there is a 100KŒ© internal resistor that then connects to the 3.3V supply. Output from the FPGA pins, specifically pins 48, 2, and 47, connect to an led which then has a 1kŒ© pull down resistor. A 3.3V from the FPGA powers the HD5P-511A seven segment display which internally has 7 leds that connect to a 1kŒ© resistor to allow for a minimal current to enter the FPGA into its corresponding ports.\nThe forward voltage would be 1.8V since that is given from a red led. Thus calculating the current we have (3.3V-1.8)/1500, which comes out to .001A or 1mA.\n\n\n\nFigure 3: Calculations, Cameron Hernandez, 9/3/2025"
  },
  {
    "objectID": "labs/lab1/lab1.html#results",
    "href": "labs/lab1/lab1.html#results",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results:",
    "text": "Results:\nThe design met all the intended design objectives. A testbench was written to ensure that the three leds flash when their requirements are met as well as ensure that the seven different leds on the seven segment display output correctly based on the input logic of the DIP switches.\n\n\n\nFigure 4: Top Module Test Bench Waveforms, Cameron Hernandez, 9/3/2025\n\n\n\n\n\nFigure 5: Top Module Test Bench Terminal Report, Cameron Hernandez, 9/3/2025\n\n\nTo test this, a submodule testbench was written which directly ensures the seven segment logic works as intended, then a top module testbench was written to make sure everything works as intended. All passed and the physical outputs match as well.\n\n\n\nFigure 6: SegmentDisp Test Bench Waveforms, Cameron Hernandez, 9/3/2025\n\n\n\n\n\nFigure 7: SegmentDisp Test Bench Terminal Report, Cameron Hernandez, 9/3/2025"
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype:",
    "text": "AI Prototype:\nI asked ChatGPT to Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg. Here Chat gave me this code as a response: //=========================================================== // Blink LED @ 2 Hz using iCE40UP5K internal HFOSC //=========================================================== module led_blink ( output logic led // Active HIGH LED output );\n// ----------------------------\n// HFOSC Primitive Instantiation\n// ----------------------------\n// Available DIV settings:\n//   2'b00 = 48 MHz\n//   2'b01 = 24 MHz\n//   2'b10 = 12 MHz\n//   2'b11 = reserved\nlogic clk_48mhz;\n\nSB_HFOSC #(\n    .CLKHF_DIV(\"0b00\")   // Select full 48 MHz\n) u_hfosc (\n    .CLKHFEN(1'b1),      // Enable HFOSC\n    .CLKHFPU(1'b1),      // Power up HFOSC\n    .CLKHF(clk_48mhz)\n);\n\n// ----------------------------\n// Parameters\n// ----------------------------\nlocalparam int COUNT_MAX = 24_000_000 - 1;  // 0.5s @ 48MHz\nlocalparam int COUNTER_WIDTH = $clog2(COUNT_MAX + 1);\n\n// ----------------------------\n// Registers\n// ----------------------------\nlogic [COUNTER_WIDTH-1:0] counter = '0;\n\n// ----------------------------\n// Counter + LED Toggle Logic\n// ----------------------------\nalways_ff @(posedge clk_48mhz) begin\n    if (counter == COUNT_MAX) begin\n        counter &lt;= '0;\n        led &lt;= ~led;  // Toggle LED every 0.5 sec\n    end\n    else begin\n        counter &lt;= counter + 1;\n    end\nend\nendmodule\nThe way Chat used syntax is a bit surprising with putting dashed lines to separate the code. Also the way it created variables is in all caps which is different from how I usually write code. Also this module only has one output and no inputs. When I tried to synthesize this code it did not pass:\nError message: &gt; prj_open ‚ÄúC:/MicroP/Lab1/Lab1.rdf‚Äù C:/MicroP/Lab1/Lab1.rdf &gt; prj_add_source ‚ÄúC:/MicroP/Lab1/source/impl_1/ChatGPT.sv‚Äù &gt; prj_run PAR -impl impl_1 0Running ‚ÄúPlace & Route Design‚Äù failed &gt; prj_run Export -impl impl_1 0Running ‚ÄúExport Files‚Äù failed When I pasted this error into Chat, Chat told me:\nGot it üôÇ ‚Äî you‚Äôre getting PAR (Place & Route) failed in Lattice Radiant when trying to build the SystemVerilog code I gave you. This usually isn‚Äôt caused by the syntax itself but rather by one of these common issues: The SB_HFOSC primitive isn‚Äôt recognized or isn‚Äôt enabled.\nThe SystemVerilog file isn‚Äôt properly added as a source in your project.\nYour constraints file (.lpf) doesn‚Äôt properly map the LED pin.\nThere‚Äôs a mismatch between your synthesis settings and the iCE40UP5K device.\nYou‚Äôre using .sv but Radiant sometimes defaults to treating HDL as Verilog-2001 unless set explicitly. //=========================================================== // led_blink.sv // Blink an LED at 2 Hz using the Lattice iCE40UP5K HFOSC //===========================================================\nmodule led_blink ( output logic led // Connect this to your LED pin in .lpf );\n// ------------------------------------------------------\n// Internal HFOSC Instantiation (Lattice-specific primitive)\n// ------------------------------------------------------\nlogic clk_48mhz;\n\nSB_HFOSC u_hfosc (\n    .CLKHF(clk_48mhz),   // Output clock\n    .CLKHFEN(1'b1),      // Enable HFOSC\n    .CLKHFPU(1'b1)       // Power up HFOSC\n);\ndefparam u_hfosc.CLKHF_DIV = \"0b00\"; // Set HFOSC to 48 MHz\n\n// ------------------------------------------------------\n// Parameters for 2 Hz LED Blinking\n// ------------------------------------------------------\nlocalparam int FREQ_HZ    = 48_000_000;   // HFOSC frequency\nlocalparam int HALF_PERIOD = FREQ_HZ / 4; // 2 Hz blink = 0.5s ON + 0.5s OFF\nlocalparam int COUNTER_WIDTH = $clog2(HALF_PERIOD);\n\n// ------------------------------------------------------\n// Registers\n// ------------------------------------------------------\nlogic [COUNTER_WIDTH-1:0] counter = '0;\n\n// ------------------------------------------------------\n// LED Blinking Logic\n// ------------------------------------------------------\nalways_ff @(posedge clk_48mhz) begin\n    if (counter == HALF_PERIOD - 1) begin\n        counter &lt;= '0;\n        led &lt;= ~led;  // Toggle LED every 0.5 seconds\n    end else begin\n        counter &lt;= counter + 1;\n    end\nend\nendmodule\nI tried to recompile it using this new code, but it honestly is still very broken and I do not think Chat is very close to properly doing this, but if I spent more time thoroughly explaining my module and what I expect my inputs and outputs to be perhaps it could get it correct."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "The Beginning of Something Great",
    "section": "",
    "text": "Reflection\nI am looking forward to this semester, the labs seem very exciting and hands on. Some skills I am hoping to learn are a better understanding of how FPGA‚Äôs are utlized in real world settings. I have used an FPGA in my most recent internship, but it was very breif and I would have liked to have pushed my understanding of how they work a little more. I am hoping to finishing all of the labs while maintaining a healthy sleep balance, however, lab 3 may have to say otherwise‚Ä¶"
  }
]